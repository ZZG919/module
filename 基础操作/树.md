# 树

## 线段树

### 线段树1（单个规则的懒标签）

多点同一规则更改，区间求和（求最大等等）

题库：[P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3372)

```c++
#include <iostream>
#include <vector>
using namespace std;
#define LL long long
//设置树的节点属性,包括的数组范围[l,r],值sum,懒标签lz
typedef struct Node{
	LL l,r,sum,lz;
}Node;
const LL N= 1000001;
LL nums[N];
Node tr[N<<2];
//聚合单个节点的值
inline void PushUp(LL loc)
{
	tr[loc].sum = tr[loc<<1].sum + tr[loc<<1|1].sum;
}
//建立树
void BuildTree(LL loc,LL l,LL r)
{
	tr[loc].l= l,tr[loc].r= r;
	tr[loc].lz=0;
	if(l==r)
	{
		tr[loc].sum=nums[l];
	}
	else
	{
		LL mid=l + (r-l)/2;
		BuildTree(loc<<1 ,l,mid);
		BuildTree(loc<<1|1,mid+1,r);
		PushUp(loc);	
	}
}
//下放懒标签
inline void PushDown(LL loc)
{
	LL &lz=tr[loc].lz; 
	tr[loc<<1].sum+= lz*(tr[loc<<1].r-tr[loc<<1].l+1);
	tr[loc<<1|1].sum+= lz*(tr[loc<<1|1].r- tr[loc<<1|1].l+1);
	tr[loc<<1].lz+=lz;
	tr[loc<<1|1].lz+=lz;
	lz=0;
}
//对数组范围内的数进行操作
void add(LL loc,LL l,LL r,LL k)
{
	if(l<=tr[loc].l && tr[loc].r<=r) 
	{
		tr[loc].sum+=k*(tr[loc].r-tr[loc].l+1);
		tr[loc].lz+=k;
	}
	else
	{
		PushDown(loc);
		if(tr[loc<<1].r>=l)
		{
			add(loc<<1, l, r, k);
		}
		if(tr[loc<<1|1].l<=r)
		{
			add(loc<<1|1, l ,r ,k);
		}
		PushUp(loc);
	}
}
//求范围内节点的总和
LL GetSum(LL loc,LL l,LL r)
{
	if(l<=tr[loc].l && tr[loc].r<=r) 
	{
		return tr[loc].sum;
	}
	else 
	{
		PushDown(loc);
		LL ans=0;
		if(tr[loc<<1].r>=l)
		{
			ans+=GetSum(loc<<1,l,r);
		}
		if(tr[loc<<1|1].l<=r)
		{
			ans+=GetSum(loc<<1|1,l,r);
		}
		return ans;
	}
}
int main() {
	long long n,m;
	scanf("%lld%lld",&n,&m);
	for(long long i=0;i<n;++i)
	{
		scanf("%lld",&nums[i]);
	}
	BuildTree(1,0,n-1);
	for(long long i=0;i<m;++i)
	{
		long long c,x,y,k;
		scanf("%lld%lld%lld",&c,&x,&y);
		if(c==1)
		{
			scanf("%lld",&k);
			add(1,x-1,y-1,k);
			continue;
		}
		printf("%lld\n",GetSum(1,x-1,y-1));
	}
    return 0;
}
```

## 前缀树

用处:Trie树，又称字典树、前缀树，是一种树形结构，是哈希树的变种，是一种用于快速检索的多叉树结构。
典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。
Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。
Trie树也有它的缺点,Trie树的内存消耗非常大。

题库：[208. 实现 Trie (前缀树) - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

```
class cnode{
public:
    bool isend;
    cnode *next[26];
    cnode()
    {
        isend=false;
        for(int i=0;i<26;i++)
            next[i]=NULL;
    }
};
class Trie {
public:
	//前缀树的根节点是空的
    cnode *head;
    Trie() {
        head=new cnode;
    }
    
    void insert(string word) {
        cnode *node=this->head;
        for(int i=0;i<word.size();i++)
        {
            int loc= word[i]-'a';
            if(!node->next[loc])
            {
                node->next[loc]=new cnode;
            }
            node=node->next[loc];
        }
        node->isend=true;
    }
    
    bool search(string word) {
        cnode *node=this->head;
        for(int i=0;i<word.size();i++)
        {
            int loc= word[i]-'a';
            if(!node->next[loc])
            {
                return false;
            }
            node=node->next[loc];
        }
        return node->isend;
    }
    
    bool startsWith(string word) {
        cnode *node=this->head;
        for(int i=0;i<word.size();i++)
        {
            int loc= word[i]-'a';
            if(!node->next[loc])
            {
                return false;
            }
            node=node->next[loc];
        }
        return true;
    }
};
```

## 树状数组

### 树状数组1

单点修改，区间求和

[P3374 【模板】树状数组 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3374)

```c++
#include <bits/stdc++.h>
#include <iostream>
using namespace std;
int n,m;
const int N =2000010;
int tree[N];
void add(int x,int k)
{
	while(x<=n)
	{
		tree[x]+=k;
		x+=x&-x;
	}
}
int sum(int x)
{
	int ans=0;
	while(x)
	{
		ans+=tree[x];
		x-=x&-x; 
	}
	return ans;
}
int main()
{
	ios::sync_with_stdio(false);
	cin>> n >>m;
	for(int i=1;i<=n;i++)
	{
		int num;
		cin >> num;
		add(i,num);
	 } 
	for(int i=1;i<=m;i++)
	{
		int a,b,c;
		cin >> a >> b >> c;
		switch(a)
		{
		case 1:add(b,c);break;
		case 2:cout << sum(c)-sum(b-1) << endl;
		}
	}
	return 0;
}
```

### 树状数组2

区间修改:包括对区间进行加或者减k，然后进行区间求和

