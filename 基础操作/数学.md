# 数学

## 最大公因数和最小公倍数

```c++
#include <iostream>
#include <vector>
using namespace std; 
//辗转相除法
int gcd(int a,int b)
{
	return a%b==0? b : gcd(b,a%b);	
} 
//最小公倍数:乘积/最小公倍数
int lcm(int a,int b)
{
	return a*b/gcd(a,b); 
} 
int main()
{
	int a=69,b=9;
	cout << gcd(a,b) << endl;
	cout << lcm(a,b) << endl;
	return 0;
}
```

## 矩阵快速幂

### 标准的的矩阵快速幂

[P3390 【模板】矩阵快速幂 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3390)

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
LL n,k;
const LL mod=1000000007; 
struct matrix{
	LL m[101][101];
	matrix(){
		memset (m,0,sizeof(m));
	}
};
matrix rm;
matrix operator*(const matrix &a,const matrix &b) {
	matrix re;
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<n;j++)
		{
			for(int l=0;l<n;l++)
			{
				re.m[i][j]+=(a.m[i][l]*b.m[l][j])%mod; 
				re.m[i][j]%=mod; 
			}
		}
	}
	return re;
}
matrix qpow(matrix &rm)
{
	matrix ans;
	for(int i=0;i<n;i++) ans.m[i][i]=1; 
	while(k)
	{
		if(k & 1)
		{
			ans=rm*ans;		
		}
		k>>=1;
		rm=rm*rm;
	}
	return ans;
}

int main()
{		
	scanf("%lld%lld",&n,&k);
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<n;j++)
		{
			scanf("%lld",&rm.m[i][j]);
		}
	}
	rm=qpow(rm);
	for(int i=0;i<n;i++)
	{ 
		for(int j=0;j<n;j++)
		{
			printf("%lld ",rm.m[i][j]%mod);
		}
		printf("\n");
	}
	return 0;
}  
```

### 矩阵快速幂应用	斐波那契数

[P1962 斐波那契数列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1962)

```c++
#include <bits/stdc++.h>
#include <iostream>
using namespace std;
const int mod = 1000000007;

struct Matrix {
    int a[3][3];
    Matrix() { memset(a, 0, sizeof a); } // 构造函数，矩阵初始化全零
    Matrix operator*(const Matrix &b) const {
        Matrix res;
        for (int i = 1; i <= 2; ++i)
            for (int j = 1; j <= 2; ++j)
                for (int k = 1; k <= 2; ++k)
                    res.a[i][j] = (res.a[i][j] + a[i][k] * b.a[k][j]) % mod;
        return res;
    }
} ans, base;

void init() { // 初始化 ans、base 矩阵
    base.a[1][1] = base.a[1][2] = base.a[2][1] = 1;
    ans.a[1][1] = ans.a[1][2] = 1;
}

void qpow(int b) { // 求
    while (b) {
        if (b & 1) ans = ans * base;
        base = base * base;
        b >>= 1;
    }
}

int main() {
    int n;
    cin >> n;
    if (n <= 2) return puts("1"), 0;
    init();
    qpow(n - 2);
    cout << ans.a[1][1] % mod << endl;
}
```

## 异或

[P2197 【模板】nim 游戏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2197)

思路：如果对手的异或值为0,那么对手最后没有值可以取。

​			相反，如果先手的异或值不为0，那么最后还有值可以取。

```c++
#include <bits/stdc++.h> 
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	cin >> n;
	for(int i=0;i<n;i++)
	{
		int t;
		cin >>t;
		int win=0;
		for(int j=0;j<t;j++)
		{
			int a;
			cin >> a;
			win^=a;
		}
		if(win) cout << "Yes" << endl;
		else cout << "No" << endl;
	}
	return 0;
}
```

## 高精度的加减乘除

### 高精度的乘法

[P1303 A*B Problem - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1303)

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
int ans[10000],ai;
void multi(string &a,string &b)
{
	for(int i=0;i<a.size();i++) 
	{
		for(int j=0;j<b.size();j++)
		{
			ans[i+j]+=(a[i]-'0')*(b[j]-'0');			
		 } 
	}  
	ai=a.size()+b.size()-1;
	int cur=0;
	for(int i=0;i<ai;i++)
	{
		cur+=ans[i];
		ans[i]=cur%10;
		cur/=10; 
	 }
	while(ai>1 && ans[ai-1]==0) ai--;  
	while(cur)
	{
		ans[ai++]+=cur%10;
		cur/=10;
	}
}
int main()
{
	string a,b;
	cin >> a >> b;
	reverse(a.begin(),a.end());
	reverse(b.begin(),b.end());
	multi(a,b);
	for(int i=ai-1;i>=0;i--)
		cout << ans[i] ;
	return 0;
}
```

## 凸包

[587. 安装栅栏 - 力扣（LeetCode）](https://leetcode.cn/problems/erect-the-fence/)

### Jarvis 算法

```c++
class Solution {
public:
    int cross(vector<int> &p,vector<int> &q,vector<int>& r)
    {
        return (q[0]-p[0])*(r[1]-p[1]) - (q[1]-p[1])*(r[0]-p[0]);
    }
    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {
        int n = trees.size();
        int leftMost = 0;
	    for(int i=1;i<n;i++)
	    {
		    if(trees[i][0]<trees[leftMost][0] ||
               (trees[i][0]==trees[leftMost][0] &&trees[i][1]<trees[leftMost][1]))
		    {
			    leftMost=i;
		    }
	    }

        vector<vector<int>> res;
        vector<bool> visit(n, false);
        int p = leftMost;
        visit[p]=true;
        res.push_back(trees[p]);
        do {
            int q = (p + 1) % n;
            for (int r = 0; r < n; r++) {
                if (cross(trees[p], trees[q], trees[r]) < 0) {
                    q = r;
                }
            }
            for(int i=0;i<n;i++)
            {
                if(i==p || i==q) continue;
                if(cross(trees[p],trees[q],trees[i])==0 && !visit[i])
                {
                    res.push_back(trees[i]);
                    visit[i]=true;
                }
            }
            if(!visit[q])
                res.push_back(trees[q]);
            visit[q]=true;
            p = q;
        } while (p != leftMost);
        return res;
    }
};
```

## 计算两个数字的共前缀：

[201. 数字范围按位与 - 力扣（LeetCode）](https://leetcode.cn/problems/bitwise-and-of-numbers-range/)

```c++
class Solution {
public:
    int rangeBitwiseAnd(int left, int right) {
        int bias=0;
        while(left<right)
        {
            left>>=1;
            right>>=1;
            bias++;
        }
        return left<<bias;
    }
};
```

