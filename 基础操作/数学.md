# 数学

## 最大公因数和最小公倍数

```c++
#include <iostream>
#include <vector>
using namespace std; 
//辗转相除法
int gcd(int a,int b)
{
	return a%b==0? b : gcd(b,a%b);	
} 
//最小公倍数:乘积/最小公倍数
int lcm(int a,int b)
{
	return a*b/gcd(a,b); 
} 
int main()
{
	int a=69,b=9;
	cout << gcd(a,b) << endl;
	cout << lcm(a,b) << endl;
	return 0;
}
```

## 矩阵快速幂

### 标准的的矩阵快速幂

[P3390 【模板】矩阵快速幂 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3390)

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
LL n,k;
const LL mod=1000000007; 
struct matrix{
	LL m[101][101];
	matrix(){
		memset (m,0,sizeof(m));
	}
};
matrix rm;
matrix operator*(const matrix &a,const matrix &b) {
	matrix re;
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<n;j++)
		{
			for(int l=0;l<n;l++)
			{
				re.m[i][j]+=(a.m[i][l]*b.m[l][j])%mod; 
				re.m[i][j]%=mod; 
			}
		}
	}
	return re;
}
matrix qpow(matrix &rm)
{
	matrix ans;
	for(int i=0;i<n;i++) ans.m[i][i]=1; 
	while(k)
	{
		if(k & 1)
		{
			ans=rm*ans;		
		}
		k>>=1;
		rm=rm*rm;
	}
	return ans;
}

int main()
{		
	scanf("%lld%lld",&n,&k);
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<n;j++)
		{
			scanf("%lld",&rm.m[i][j]);
		}
	}
	rm=qpow(rm);
	for(int i=0;i<n;i++)
	{ 
		for(int j=0;j<n;j++)
		{
			printf("%lld ",rm.m[i][j]%mod);
		}
		printf("\n");
	}
	return 0;
}  
```

### 矩阵快速幂应用	斐波那契数

[P1962 斐波那契数列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1962)

```c++
#include <bits/stdc++.h>
#include <iostream>
using namespace std;
const int mod = 1000000007;

struct Matrix {
    int a[3][3];
    Matrix() { memset(a, 0, sizeof a); } // 构造函数，矩阵初始化全零
    Matrix operator*(const Matrix &b) const {
        Matrix res;
        for (int i = 1; i <= 2; ++i)
            for (int j = 1; j <= 2; ++j)
                for (int k = 1; k <= 2; ++k)
                    res.a[i][j] = (res.a[i][j] + a[i][k] * b.a[k][j]) % mod;
        return res;
    }
} ans, base;

void init() { // 初始化 ans、base 矩阵
    base.a[1][1] = base.a[1][2] = base.a[2][1] = 1;
    ans.a[1][1] = ans.a[1][2] = 1;
}

void qpow(int b) { // 求
    while (b) {
        if (b & 1) ans = ans * base;
        base = base * base;
        b >>= 1;
    }
}

int main() {
    int n;
    cin >> n;
    if (n <= 2) return puts("1"), 0;
    init();
    qpow(n - 2);
    cout << ans.a[1][1] % mod << endl;
}
```

